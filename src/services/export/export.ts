/**
 * Export functionality for AlgoLens
 * Supports image, video, and code exports
 */

import html2canvas from "html2canvas";

// Export types
export interface ExportOptions {
  format: "png" | "svg" | "pdf" | "mp4" | "gif" | "code";
  quality?: number;
  width?: number;
  height?: number;
  fps?: number;
  duration?: number;
  includeUI?: boolean;
  watermark?: boolean;
}

// Export result interface
export interface ExportResult {
  success: boolean;
  data?: string | Blob;
  error?: string;
  filename?: string;
}

// Image export functionality
export async function exportAsImage(
  element: HTMLElement,
  options: ExportOptions = { format: "png" }
): Promise<ExportResult> {
  try {
    const canvas = await html2canvas(element, {
      useCORS: true,
      allowTaint: true,
      backgroundColor: "#ffffff",
      scale: options.quality || 2,
      width: options.width,
      height: options.height,
      removeContainer: true,
    });

    const dataUrl = canvas.toDataURL(`image/${options.format}`, 0.9);
    const filename = `algolens-${Date.now()}.${options.format}`;

    // Add watermark if requested
    if (options.watermark) {
      const watermarkedCanvas = await addWatermark(canvas);
      const watermarkedDataUrl = watermarkedCanvas.toDataURL(
        `image/${options.format}`,
        0.9
      );
      downloadDataUrl(watermarkedDataUrl, filename);
      return { success: true, data: watermarkedDataUrl, filename };
    }

    downloadDataUrl(dataUrl, filename);
    return { success: true, data: dataUrl, filename };
  } catch (error) {
    console.error("Image export failed:", error);
    return { success: false, error: String(error) };
  }
}

// SVG export functionality
export async function exportAsSVG(
  element: HTMLElement,
  options: ExportOptions = { format: "svg" }
): Promise<ExportResult> {
  try {
    const svgString = await elementToSVG(element);
    const blob = new Blob([svgString], { type: "image/svg+xml" });
    const filename = `algolens-${Date.now()}.svg`;

    // Optional watermark for SVG when requested
    if (options.watermark) {
      // Simple approach: append comment indicating watermark
      const watermarked = svgString + "\n<!-- Generated by AlgoLens -->";
      const wmBlob = new Blob([watermarked], { type: "image/svg+xml" });
      downloadBlob(wmBlob, filename);
      return { success: true, data: wmBlob, filename };
    }

    downloadBlob(blob, filename);
    return { success: true, data: blob, filename };
  } catch (error) {
    console.error("SVG export failed:", error);
    return { success: false, error: String(error) };
  }
}

// PDF export functionality
export async function exportAsPDF(
  element: HTMLElement,
  options: ExportOptions = { format: "pdf" }
): Promise<ExportResult> {
  try {
    // We'll use jsPDF for PDF generation
    const { jsPDF } = await import("jspdf");

    const canvas = await html2canvas(element, {
      useCORS: true,
      allowTaint: true,
      backgroundColor: "#ffffff",
      scale: 2,
    });

    const imgData = canvas.toDataURL("image/png");
    const pdf = new jsPDF({
      orientation: canvas.width > canvas.height ? "landscape" : "portrait",
      unit: "mm",
      format: "a4",
    });

    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = (canvas.height * pdfWidth) / canvas.width;

    pdf.addImage(imgData, "PNG", 0, 0, pdfWidth, pdfHeight);

    if (options.watermark) {
      pdf.setFontSize(10);
      pdf.setTextColor(128, 128, 128);
      pdf.text("Generated by AlgoLens", 10, pdfHeight - 10);
    }

    const filename = `algolens-${Date.now()}.pdf`;
    pdf.save(filename);

    return { success: true, filename };
  } catch (error) {
    console.error("PDF export failed:", error);
    return { success: false, error: String(error) };
  }
}

// Video recording functionality
export class VideoRecorder {
  private mediaRecorder: MediaRecorder | null = null;
  private chunks: Blob[] = [];
  private stream: MediaStream | null = null;

  async startRecording(
    element: HTMLElement,
    options: ExportOptions = { format: "mp4", fps: 30 }
  ): Promise<void> {
    try {
      // Capture the element as a stream
      this.stream =
        (await (element as HTMLCanvasElement).captureStream?.(options.fps)) ||
        (await this.createStreamFromElement(element, options.fps || 30));

      this.mediaRecorder = new MediaRecorder(this.stream, {
        mimeType: "video/webm;codecs=vp9",
      });

      this.chunks = [];

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.chunks.push(event.data);
        }
      };

      this.mediaRecorder.start(100); // Record in 100ms chunks
    } catch (error) {
      console.error("Failed to start video recording:", error);
      throw error;
    }
  }

  async stopRecording(): Promise<ExportResult> {
    return new Promise((resolve) => {
      if (!this.mediaRecorder) {
        resolve({ success: false, error: "No recording in progress" });
        return;
      }

      this.mediaRecorder.onstop = () => {
        const blob = new Blob(this.chunks, { type: "video/webm" });
        const filename = `algolens-${Date.now()}.webm`;

        downloadBlob(blob, filename);

        // Clean up
        if (this.stream) {
          this.stream.getTracks().forEach((track) => track.stop());
        }

        resolve({ success: true, data: blob, filename });
      };

      this.mediaRecorder.stop();
    });
  }

  private async createStreamFromElement(
    element: HTMLElement,
    fps: number
  ): Promise<MediaStream> {
    // Create a canvas to capture the element
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d")!;

    canvas.width = element.offsetWidth;
    canvas.height = element.offsetHeight;

    // Capture frames at specified FPS
    const captureFrame = async () => {
      const elementCanvas = await html2canvas(element, {
        useCORS: true,
        allowTaint: true,
        backgroundColor: "transparent",
      });

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(elementCanvas, 0, 0);
    };

    // Start capturing frames
    const interval = setInterval(captureFrame, 1000 / fps);

    // Clean up on stream end
    setTimeout(() => clearInterval(interval), 30000); // Max 30 seconds

    return canvas.captureStream(fps);
  }
}

// GIF export functionality
export async function exportAsGIF(
  element: HTMLElement,
  options: ExportOptions = { format: "gif", fps: 10, duration: 5 }
): Promise<ExportResult> {
  try {
    const { default: GIF } = await import("gif.js");

    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: element.offsetWidth,
      height: element.offsetHeight,
      workerScript: "/gif.worker.js", // You'll need to add this to public folder
    });

    const frames = await captureFrames(
      element,
      options.fps || 10,
      options.duration || 5
    );

    frames.forEach((frame) => {
      gif.addFrame(frame, { delay: 1000 / (options.fps || 10) });
    });

    return new Promise((resolve) => {
      gif.on("finished", (blob: Blob) => {
        const filename = `algolens-${Date.now()}.gif`;
        downloadBlob(blob, filename);
        resolve({ success: true, data: blob, filename });
      });

      gif.on("progress", (p: number) => {
        console.log(`GIF encoding progress: ${Math.round(p * 100)}%`);
      });

      gif.render();
    });
  } catch (error) {
    console.error("GIF export failed:", error);
    return { success: false, error: String(error) };
  }
}

// Code export functionality
export async function exportCode(
  algorithm: string,
  language: "javascript" | "python" | "java" | "cpp" = "javascript"
): Promise<ExportResult> {
  try {
    const codeTemplates = getCodeTemplates();
    const template = (codeTemplates as Record<string, Record<string, string>>)[
      algorithm
    ]?.[language];

    if (!template) {
      throw new Error(
        `Code template not found for ${algorithm} in ${language}`
      );
    }

    const code = generateCode(template, algorithm);
    const filename = `${algorithm}.${getFileExtension(language)}`;

    downloadText(code, filename);
    return { success: true, data: code, filename };
  } catch (error) {
    console.error("Code export failed:", error);
    return { success: false, error: String(error) };
  }
}

// Utility functions
async function addWatermark(
  canvas: HTMLCanvasElement
): Promise<HTMLCanvasElement> {
  const ctx = canvas.getContext("2d")!;

  // Add semi-transparent watermark
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = "#6366f1";
  ctx.font = "16px Inter, sans-serif";
  ctx.textAlign = "right";
  ctx.fillText("AlgoLens", canvas.width - 20, canvas.height - 20);
  ctx.restore();

  return canvas;
}

async function elementToSVG(element: HTMLElement): Promise<string> {
  const { width, height } = element.getBoundingClientRect();

  // Create SVG namespace
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", width.toString());
  svg.setAttribute("height", height.toString());
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

  // Convert element to foreign object
  const foreignObject = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "foreignObject"
  );
  foreignObject.setAttribute("width", "100%");
  foreignObject.setAttribute("height", "100%");

  // Clone the element to avoid modifying the original
  const clonedElement = element.cloneNode(true) as HTMLElement;
  foreignObject.appendChild(clonedElement);
  svg.appendChild(foreignObject);

  // Serialize to string
  const serializer = new XMLSerializer();
  return serializer.serializeToString(svg);
}

async function captureFrames(
  element: HTMLElement,
  fps: number,
  duration: number
): Promise<HTMLCanvasElement[]> {
  const frames: HTMLCanvasElement[] = [];
  const totalFrames = fps * duration;
  const frameDelay = 1000 / fps;

  for (let i = 0; i < totalFrames; i++) {
    const canvas = await html2canvas(element, {
      useCORS: true,
      allowTaint: true,
      backgroundColor: "transparent",
    });

    frames.push(canvas);

    // Wait for next frame
    await new Promise((resolve) => setTimeout(resolve, frameDelay));
  }

  return frames;
}

function downloadDataUrl(dataUrl: string, filename: string): void {
  const link = document.createElement("a");
  link.download = filename;
  link.href = dataUrl;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.download = filename;
  link.href = url;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

function downloadText(text: string, filename: string): void {
  const blob = new Blob([text], { type: "text/plain" });
  downloadBlob(blob, filename);
}

function getFileExtension(language: string): string {
  const extensions: Record<string, string> = {
    javascript: "js",
    python: "py",
    java: "java",
    cpp: "cpp",
  };
  return extensions[language] || "txt";
}

function getCodeTemplates() {
  return {
    "bubble-sort": {
      javascript: `
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}`,
      python: `
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr`,
      java: `
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}`,
      cpp: `
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}`,
    },
    // Add more algorithm templates here
  };
}

function generateCode(template: string, algorithm: string): string {
  const header = `/**
 * ${algorithm.replace("-", " ").toUpperCase()} Algorithm
 * Generated by AlgoLens
 * ${new Date().toISOString()}
 */

`;

  return header + template.trim();
}

// Export hook for easy integration
export function useExport() {
  const exportImage = async (element: HTMLElement, options?: ExportOptions) => {
    return await exportAsImage(element, options);
  };

  const exportSVG = async (element: HTMLElement, options?: ExportOptions) => {
    return await exportAsSVG(element, options);
  };

  const exportPDF = async (element: HTMLElement, options?: ExportOptions) => {
    return await exportAsPDF(element, options);
  };

  const exportGIF = async (element: HTMLElement, options?: ExportOptions) => {
    return await exportAsGIF(element, options);
  };

  const startVideoRecording = async (
    element: HTMLElement,
    options?: ExportOptions
  ) => {
    const recorder = new VideoRecorder();
    await recorder.startRecording(element, options);
    return recorder;
  };

  const exportAlgorithmCode = async (
    algorithm: string,
    language?: "javascript" | "python" | "java" | "cpp"
  ) => {
    return await exportCode(algorithm, language);
  };

  return {
    exportImage,
    exportSVG,
    exportPDF,
    exportGIF,
    startVideoRecording,
    exportAlgorithmCode,
  };
}
